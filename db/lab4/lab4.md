# Лабораторна робота 4 – Аналітичні SQL-запити (OLAP)

У цій лабораторній роботі я використовую схему Campus Events з попередніх лабораторних робіт і виконую аналітичні запити з агрегатами, групуванням, різними видами JOIN та підзапитами.

## Query 1 – Кількість рядків у основних таблицях

Запит рахує кількість записів у таблицях `User`, `Event`, `Category`, `EventParticipant` і `Comment`.  
Дозволяє швидко оцінити розмір основних сутностей бази.

## Query 2 – Кількість подій за статусом

Групує події за полем `status` (`draft`, `published`, `cancelled`) і рахує, скільки подій у кожному статусі.  
Показує загальний розподіл подій за станом публікації.

## Query 3 – Статистика місткості подій за видимістю

Групує події за `visibility` (`public`, `private`) і для кожної групи рахує:
- кількість подій,
- середню місткість (`AVG(capacity)`),
- мінімальну та максимальну місткість.

Це дозволяє порівняти характеристики публічних і приватних подій.

## Query 4 – Події з більш ніж одним учасником

За допомогою `INNER JOIN` між `Event` та `EventParticipant` обчислюється кількість учасників для кожної події.  
Через `HAVING COUNT(ep.id) > 1` вибираються лише ті події, де більше одного учасника.  
Результат показує найпопулярніші події.

## Query 5 – Сумарна кількість учасників для подій кожного організатора

З'єднує таблиці `User` (організатор), `Event` (створені ним події) і `EventParticipant`.  
Рахує кількість учасників зі статусом `going` для всіх подій кожного організатора.  
Дає уявлення, хто з організаторів збирає найбільшу аудиторію.

## Query 6 – Коментарі з назвою події та автором

Використовує `INNER JOIN` між `Comment`, `Event` та `User`, щоб показати:
- назву події,
- ім'я автора,
- текст коментаря і час створення.

Це «розгорнутий» список коментарів із усією потрібною контекстною інформацією.

## Query 7 – Кількість коментарів для кожної події

Використовується `LEFT JOIN` від `Event` до `Comment`, тому виводяться всі події, навіть без жодного коментаря (для них кількість буде 0).  
Запит показує рівень залученості користувачів до кожної події.

## Query 8 – Події з місткістю вище за середню

У підзапиті обчислюється середня місткість усіх подій з ненульовою `capacity`.  
Основний запит вибирає лише ті події, у яких `capacity` більша за це середнє значення.  
Це дозволяє знайти «найбільші» події за розміром аудиторії.

## Query 9 – Кількість учасників через корельований підзапит

Для кожної події в `SELECT` виконується корельований підзапит до `EventParticipant`, який рахує кількість записів з відповідним `event_id`.  
Так можна отримати число учасників без явного `JOIN` і `GROUP BY`.

## Query 10 – Порівняння згадувань користувачів у подіях і коментарях

У двох підзапитах окремо рахується кількість згадувань користувачів у таблицях `EventMention` та `CommentMention`.  
Ці підзапити об'єднуються через `FULL JOIN`, щоб врахувати користувачів, які зустрічаються лише в одній з таблиць.  
Потім результат з'єднується з таблицею `User`, щоб показати ім'я користувача та кількість згадувань у подіях і коментарях.

## Query 11 – Категорії з кількістю подій вище середньої

Спершу для кожної категорії рахується кількість пов'язаних подій через `LEFT JOIN` `Category` + `EventCategory`.  
У вкладеному підзапиті обчислюється середня кількість подій на категорію.  
У `HAVING` залишаються тільки ті категорії, де кількість подій перевищує це середнє.  
Запит показує «найактивніші» категорії у системі.
